Based on BootLeaf, but updated to newer leaflet and bootstrap, 
elimination of dependancy on jquery, removes typeahead (not updated
for several years) in favor of a newer library, eliminate dependancy
on mapbox plugins (only use "official" plugins from leaflet).

Might be nice to make it oh-s--portable by sucking in a JSON file:
Center: [lat: {lat}, lng: {lng} ],
Data: [
    Pizza: pizza.json,
    Burgers: burgers.json,
    Supermarkets: supers.json,
],
Title: Title for loaded page,
Logo: {
    Text: {text},
    Icon: {icon.png},
}


Includes data for pizzas and hamburgers in Asuncion, Paraguay.
Include notes on how to customize (location, theme, data)

So I've forgotten a bit about javascript modules, but this will be a great
exercise.

Hmmm... maybe add a voice interface (show a microphone icon, press it and) say
"tetonas" or "rubias", or "san lorenzo"

============================================

// A fairly generalized search algorith for data arrays
//

const search = (event, objectData = [], setReturnedData, combinations = []) => {
  // prevent page refresh
  event.preventDefault();

  // sniff out user input/search values and convert to lower-case
  const input = event.target.value.toLowerCase();

  // store the filtered results in : "const result"
  const result = objectData.filter((data) => {
    // initialize a variable to store combos in : "let combinationQueries = ""
    let combinationQueries = "";

    // loop over the combo values paseed by users
    combinations.forEach((arg) => {
      // first check if the current combo value exists in the object then ...
      // add them together
      combinationQueries +=
        data.hasOwnProperty(arg) && data[arg].toLowerCase().trim() + " ";
    });
    /*
        loop over current "Object keys" and return the first
        successful search match (".some()" at work here)
         */
    return Object.keys(data).some((key) => {
      /**
       * return first successful search query match but...
       * do not return if value is "undefined", "null", false, true,  and...
       * trim values to remove trailing whitespaces
       */
      return (
        (data[key] !== undefined &&
          data[key] !== null &&
          /**
           * activate/uncomment the feature/code below if you don't wanna filter by boolean values
           * e.g isActive fields, or isActivated fields
           */
          // data[key] !== false && data[key] !== true &&
          JSON.stringify(data[key]).toLowerCase().trim().includes(input)) ||
        combinationQueries.trim().includes(input)
      );
    });
  });
  // function to recieve the result of the search query data
  setReturnedData(result);
};

export default search;
=========================================
Getting Bus Routes:
OpenStreetMap with public transport layer (?layers=T or something)
Pick a bus route.
Get the OSRM id (or whatever it's called) of the route 
Figure out the primary bus routes we want to have on hand.
Need to go to:
Villa Mora, Terminal, Botanical, FDO Norte, FDO Sur, maybe a couple others.
From Hostel to Obrero, Sajonia, etc (supermarkets)
Parks, cofee shops...

Go to overpass-turbo.eu and export the route as JSON
Take the JSON and use osmtogeojson (on github) to export geoJSON.
Maybe use simplify.js to reduce the points count if it's from a shaky
GPS route or something.

SO just get the dozen most useful bus routes
(38, 12, 23...) and not the million we'll never use.

Show these on the map?  Can we put a dropdown in the layer selector?
Or collapse groups?
================================================
https://github.com/oskosk/Leaflet.Weather\
===================================================
Add to nginx config
Maybe also add json5 mime type, but maybe not.

        location ~ /.*\.md {
            root /opt/openrvdas;
            default_type text/html;
            charset UTF-8;
            add_before_body /js/StrapDown.js/prepend;
            add_after_body /js/StrapDown.js/postpend;
        }

========================================================
Workflow for getting bus route
Go to OpenStreetMap.  Select transport layer.
"Query Features" and click the route you want
Sort through the list.  You're looking for a "Relation" that
hopefully is named with your bus route's name.
Note the relation number

IN the overpass-turbo.eu editor, make your query look like this:
[out:json][timeout:25];
// gather results
(
  // substitute the id the relation(e.g. route) that you want to query
  relation(9644636); >>;
);
// print results
out geom;
>;
out skel qt;

Where the "relation()" is filled in with your relation number.

hmmm... there seems to be a way to directly download the data using an API 
(maybe POST the query).  We could run through a processor like osm2geojson,
then load the geojson and strip all the "points" (removing traffic
lights and intersections).  Then maybe look at some linestring compression
(simplify.js, but probably not very necessary) and google polyline encoding to save bandwidth (if the 
geogjon looks to be large).
 

